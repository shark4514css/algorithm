1. 堆的定义：同时满足两个条件
   （1）堆是一个完全二叉树
   （2）堆中每一个节点的值都必须大于等于（或小于等于）其子树中的每个节点的值
   每个节点的值都大于等于子树中每个节点的值的堆，叫作小顶堆
   每个节点的值都小于等于子树中每个节点的值的堆，叫作大顶堆
2. 堆的操作
   插入节点： 先插到最后一个位置，再不断做上浮操作
   删除节点（堆顶的节点）： 把最后一个元素替换到堆顶，然后不断做下沉操作
   构建二叉堆： 从最后一个非叶子节点开始，如果他大于左右节点任一个（小顶堆举例），那就做下沉操作，再依次对其他非叶子节点做同样的操作
   堆的插入和删除操作的时间复杂度都是O（logn），构建堆的操作看似是O（nlogn），但实际上是O（n），参加第5点
   代码实现：父节点和子节点交换的时候，不用真的交换，只需要先把交换一方存入temp，做单向覆盖，循环结束后，再把temp存入交换后的最终位置
3. 优先队列
   最大优先队列： 无论入队顺序如何，都是当前最大元素先出队
   最小优先队列： 无论入队顺序如何，都是当前最小元素先出队
   实现这样的需求，用线性数据结构时间复杂度较高，可以用二叉堆来实现，用大顶堆实现最大优先队列
   应用： 赫夫曼编码，图的最短路径，最小生成树算法等等
4. 优先级队列的应用
   （1）合并有序小文件
   （2）高性能定时器
5. 优先队列操作
   入队操作： 在堆的最后插入节点，再上浮到合适的位置
   出队操作： 和删除堆顶元素一致
   两个操作时间复杂度都是O（logn）
6. 堆排序
   两个步骤： 建堆 + 排序
   构建：
   将数组原地构建成一个堆，两种思路：
   （1）我们假设，起初堆中只包含一个数据，就是下标为1的数据，然后我们调用插入节点操作，将下标为2到n的数据依次插入堆中
   （2）从后往前处理数组，并且每个数据都是从上往下堆化（对于大顶堆）
       叶子节点往下堆化只能和自己比较，所以直接从最后一个非叶子节点开始，同第2点构建二叉堆里的操作相同
   为什么时间复杂度是O（n）
   因为叶子节点不用处理，所以需要堆化的节点从倒数第二层开始，每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度k成正比
   最顶点的节点个数是2^0,高度是h，第k行节点个数是2^（k-1），高度是h-k，所以需要比较和交换的总和就是
   S = 2^0 * h + …… + 2^（k-1) * (h-k)
   错位相减S = -h + 2^h-2 + 2^h = 2^(h+1)-h-2
   而h = log2底n，所以S=O（n）
   排序：
   建堆结束后，数组中的数据已经按照大顶堆的特性组织了，最大元素就在堆顶。
   把堆顶元素和最后一个元素交换，最大元素就放到了下标n的位置。
   堆顶元素移除后，把第n个元素放在堆顶，然后将剩下n-1个元素重新构建成堆。以此类推，排序过程时间复杂度是nlogn
   多以总的时间复杂度就是nlogn
   堆排序是不稳定的排序算法
7. 利用堆求topK问题
   问题有两种，针对静态数据集合，针对动态数据集合（有数据动态被加入进去）
   （1）静态数据问题： 如何在一个包含n个数据的数组中，查找前K大数据呢？
   维护一个大小为K的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。
   如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入堆中，如果比堆顶元素还小，就不做处理。
   遍历结束，堆中数据就是前K大数据
   （2）动态插入数据问题
   插入的数据再和堆顶元素比较，如果比堆顶元素大，则删除堆顶元素，并把新数据插入堆中
8. 利用堆求中位数
   求动态数据集合的中位数，中位数在不停变化，如果再用排序再取中位数的方式，效率就不高了
   借助堆来求中位数，不用排序也可以高效的求中位数
   step1 需要两个堆，一个大顶堆，一个小顶堆，大顶堆存储数据前半部分，小顶堆存储数据后半部分，小顶堆中的数据都大于大顶堆的数据
   step2 大顶堆的堆顶元素，就是中位数（如果总数为奇数，大顶堆存储的数据比小顶堆多一个）
   step3 新加入的数据小于等于大顶堆的堆顶元素，我们就将这新数据插入大顶堆，否则，插入小顶堆
   step4 移动两个堆中的数据满足如果总数为奇数，大顶堆存储的数据比小顶堆多一个，偶数的话两者个数相同
9. 利用堆求其他百分位的数据（百分之99接口响应时间）
   99百分位指的是1，2，……，100，99百分位就是99，因为小于等于99的数占总个数的99%
   维护两个堆，大顶堆保存n*99%个数据，小顶堆存储n*1%个数据，小顶堆的数据都大于大顶堆的数据，那么大顶堆堆顶的数据就是所求
   每次插入一个数据，都和大顶堆堆顶的数据进行比较，如果比他小，就插入大顶堆，反之，插入小顶堆
   每次插入都要重新计算，两个堆的数据个数是否还符合99：1，如果不符合，就要移动数据
   每次插入操作，可能会涉及几个数据的堆化操作，时间复杂度是O（logn）每次求99%响应时间的时候，直接返回大顶堆的堆顶元素，时间复杂度O（1）
   
   
   
   
   
   
   
   
   
