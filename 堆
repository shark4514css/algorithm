1. 堆的定义：同时满足两个条件
   （1）堆是一个完全二叉树
   （2）堆中每一个节点的值都必须大于等于（或小于等于）其子树中的每个节点的值
   每个节点的值都大于等于子树中每个节点的值的堆，叫作小顶堆
   每个节点的值都小于等于子树中每个节点的值的堆，叫作大顶堆
2. 堆的操作
   插入节点： 先插到最后一个位置，再不断做上浮操作
   删除节点（堆顶的节点）： 把最后一个元素替换到堆顶，然后不断做下沉操作
   构建二叉堆： 从最后一个非叶子节点开始，如果他大于左右节点任一个（小顶堆举例），那就做下沉操作，再依次对其他非叶子节点做同样的操作
   堆的插入和删除操作的时间复杂度都是O（logn），构建堆的操作看似是O（nlogn），但实际上是O（n），参加第5点
   代码实现：父节点和子节点交换的时候，不用真的交换，只需要先把交换一方存入temp，做单向覆盖，循环结束后，再把temp存入交换后的最终位置
3. 优先队列
   最大优先队列： 无论入队顺序如何，都是当前最大元素先出队
   最小优先队列： 无论入队顺序如何，都是当前最小元素先出队
   实现这样的需求，用线性数据结构时间复杂度较高，可以用二叉堆来实现，用大顶堆实现最大优先队列
   应用： 赫夫曼编码，图的最短路径，最小生成树算法等等
4. 优先级队列的应用
   （1）合并有序小文件
5. 优先队列操作
   入队操作： 在堆的最后插入节点，再上浮到合适的位置
   出队操作： 和删除堆顶元素一致
   两个操作时间复杂度都是O（logn）
6. 堆排序
   两个步骤： 建堆 + 排序
   构建：
   将数组原地构建成一个堆，两种思路：
   （1）我们假设，起初堆中只包含一个数据，就是下标为1的数据，然后我们调用插入节点操作，将下标为2到n的数据依次插入堆中
   （2）从后往前处理数组，并且每个数据都是从上往下堆化（对于大顶堆）
       叶子节点往下堆化只能和自己比较，所以直接从最后一个非叶子节点开始，同第2点构建二叉堆里的操作相同
   为什么时间复杂度是O（n）
   因为叶子节点不用处理，所以需要堆化的节点从倒数第二层开始，每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度k成正比
   最顶点的节点个数是2^0,高度是h，第k行节点个数是2^（k-1），高度是h-k，所以需要比较和交换的总和就是
   S = 2^0 * h + …… + 2^（k-1) * (h-k)
   错位相减S = -h + 2^h-2 + 2^h = 2^(h+1)-h-2
   而h = log2底n，所以S=O（n）
   排序：
   建堆结束后，数组中的数据已经按照大顶堆的特性组织了，最大元素就在堆顶。
   把堆顶元素和最后一个元素交换，最大元素就放到了下标n的位置。
   堆顶元素移除后，把第n个元素放在堆顶，然后将剩下n-1个元素重新构建成堆。以此类推，排序过程时间复杂度是nlogn
   多以总的时间复杂度就是nlogn
   堆排序是不稳定的排序算法
   
   
   
   
   
   
   
   
