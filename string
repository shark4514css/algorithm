1. BF算法和RK算法都是单模式串匹配的算法，一个串跟一个串进行匹配
2. BF算法是暴力匹配算法。
   主串、模式串： 在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串，主串长度n，模式串m，n>m
   BF算法的思想就是，我们在主串中检查起始位置分别是0、1、2、……n-m,看有没有和模式串匹配的，最坏情况的时间复杂度是O（n*m）
   虽然时间复杂度很高，但是比较常用，因为十几种大部分情况下，模式串和主串的长度都不会太长。而且每次匹配的时候，当中途遇到不能匹配的字符的时候就可以停止了
   所以从统计意义上，真实的效率要高很多
   另一个原因是思想简单，不容易出错
3. RK算法
   BF算法的思想是：如果主串长度n，模式串m，那么在主串中就会有n-m+1个长度为m的子串，我们只需要暴力的对比这n-m+1个子串与模式串，就可以找出主串与模式串匹配的子串
   RK算法通过哈希算法进行升级
   对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，不考虑哈希冲突的话，只需要进行数字的比较，效率大大提升
   然而，通过哈希算法计算子串的哈希值的时候，需要遍历子串中的每个字符，算法整体的效率并没有提升
   假设要匹配的字符串只包括K个字符，我们就可以用一个K进制来表示一个子串，这个K进制转化成十进制，作为子串的哈希值
   这种哈希算法有一个特点：
   相邻两个子串的哈希值的计算公式特点，有一大部分是交集
   计算子串哈希值时间复杂度是O（n）
   模式串哈希值与每个子串比较时间复杂度是O（1），总共需要比较（n-m+1）个，所以也是O（n）
   所以总体时间复杂度就是O（n）
