一、排序算法的执行效率
1. 最好情况、最坏情况、平均情况时间复杂度
   对于有序度不同的数据，对于排序的执行时间的影响
2. 时间复杂度的系数、常数、低阶
   平时计算时间复杂度的时候都忽略常数和低阶，但是平时排序的时候n可能没那么大，就要把这些也考虑进来
3. 比较次数和交换次数

二、排序算法的内存消耗
O(1)空间复杂度的排序算法： 原地排序

三、排序算法的稳定性
如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就是稳定排序
2， 3， 9， 4， 3
两个3，排序后先后顺序不变
实际情况中排序的不一定是整数，也可能是某个对象的key值，比如金额，可能会关注稳定性。稳定排序算法可以保持金额相同的两个对象，排序之后的前后顺序不变。

四、三种时间复杂度是O(n^2)的排序算法
   冒泡、插入、选择
   
五、冒泡排序
1. 冒泡排序只会操作相邻的两个数据。
2. 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
3. 如果不满足就互换。
4. 每次冒泡都会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作
   
1. 冒泡排序是原地排序
2. 冒泡排序是稳定排序
3. 冒泡排序时间复杂度 最好O(n) 最坏O（n^2） 

有序度分析平均时间复杂度
有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是  a[i] <= a[j](i < j)
比如2， 4， 3， 1， 5， 6有序度是11，因为有序数组：
（2，4）（3，3） （2，5） （2， 6） （4， 5） （4， 6） （3， 5） （3， 6） （1， 5） （1，6） （5， 6）
完全有序的数组叫做满有序度
逆序度的定义刚好和有序度相反
逆序度 = 满有序度 - 有序度

冒泡排序平均有序度n(n-1)/ 4 平均时间复杂度O(n^2)  不严格，但是可以估算出平均时间复杂度

六、插入排序
包含两种操作，一种是元素的比较，一种是元素的移动
1， 插入排序是原地排序
2， 插入排序是稳定排序
3， 最好时间复杂度是O（n），最坏时O（n^2）,因为在数组中插入一个数据的平均复杂度是O（n），所以插入排序的平均时间复杂度是O（n^2）

为什么插入排序比冒泡排序更受欢迎？
从代码实现上，冒泡复杂，冒泡需要3个赋值操作，插入排序需要一个赋值操作
而且插入排序还有优化空间

七、选择排序
和插入排序类似。选择排序每次都要从还没排序的数据中找到最小的元素，将其放到已排序区间的末尾
1， 选择排序是一种原地排序算法
2， 选择排序不是一种稳定算法
比如 5 8 5 2 9
第一次选择2，与第一个元素交换位置 变成2 8 5 5 9 已经改变了先后顺序

八、归并排序
适合大规模数据排序，用到了分治思想

归并排序： 要排序一个数组，先把数组分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合并在一起，这样整个数组都是有序的了。
分治思想跟递归很像。分支是一种解决问题的处理思想，递归是一种编程技巧。

1. 归并排序是稳定排序
2. 时间复杂度
   T（n）= T(n/2) * 2 + n
   所以T(n / 2^ k) = T(1),T(n) = T(nlogn) 最好、最坏、平均时间复杂度都是T(nlogn)，因为归并排序的时间复杂度和数组初始情况的有序度无关
3. 空间复杂度
   归并复杂度有个致命的缺点，它不是原地排序
   空间复杂度是O（n）用于存储n个数据  每次合并操作后，临时开辟的内存空间被释放掉

九、快速排序
