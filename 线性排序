时间复杂度是O(n)的排序算法，他们对于要排序的数据要求很苛刻
桶排序、计数排序、基数排序
一， 桶排序
1， 要将排序的数据分到几个有序的桶里，每个桶里的数据单独进行排序。
桶内排序完之后，再把每个桶里的数据按照顺序取出，组成的序列就是有序的了

2， 时间复杂度

假如我们要排序的数据有n个，我们把它们均匀的划分到m个桶里，每个桶里就有k=n/m个元素。每个桶内使用快排，
时间复杂度是O（k*logk）,整个时间复杂度就是O（n*log(n/m)）
当m无限接近n的时候log（n/m）无限接近1，总的时间复杂度就是O（n）

3， 上述分析做了很多假设，实际上桶排序对要排序的数据的要求十分苛刻
（1）要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序，这样桶与桶之间不用再排序
（2）数据在各个桶之间分布比较均匀，否则极端情况都划分在一个桶里，那就是O（n*logn）

4. 桶排序比较适合用在外部排序中

二、计数排序
计数排序是桶排序的一种特殊情况。
当要排序的n个数据，所处的范围并不大，比如最大值是k，那我们把数据分成k个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间
比如一个数组2，5，3，0，2，3，0，3
A[8] = [2,5,3,0,2,3,0,3]
C[6] = [2,0,2,3,0,1]  第i个元素表示A【8】中i出现的次数
对C【6】进行从左开始求和，得到下面数组
D【6】=【2，2，4，7，7，8】第i个元素表示A【8】中小于等于i的个数
那么对A【8】从后往前遍历，最后一个数字是3，查D【6】的第3的元素，是7，表示小于等于3的元素有7个，那么对于结果，就把这个3放在第7的位置上
并把D【6】中的第3个元素7，减一变成6，代表还没排好序的元素中小于等于3的元素有6个

计数排序只能用在数据范围不大的场景，如果数据范围k比要排序的数据n大很多，就不适合了

而且，计数排序只能给非负整数排序，如果排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数

三、基数排序
比如给手机号码排序，手机号码有11位，显然不适合用前面两种排序方法
这个问题有这样的规律，如果手机号码的前几位中a的手机号码已经比b大了，那么后面的位数就不用看了

可以借助稳定排序算法的处理思路，先按照最后一位排序手机号码，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序，经过11位排序之后，手机号码就都有序了

对于不等长的数据，可以用基数排序么
实际上，我们可以把所有单词补齐到相同长度，位数不够的可以在后面补‘0’，根据ASCII值，所有字母都大于0

基数排序对数据有要求，需要可以分割出独立的位来比较，而且位之间有递进关系，如果a数据的高位比b数据搭，那剩下的低位就不用比较了。
此外每个位的数据范围不能太大，要可以用线性排序算法来排序，否则时间复杂度就不是O（n）了
